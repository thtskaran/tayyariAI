# app.py
import os
import uuid
from flask import Flask, request, jsonify, send_from_directory
from werkzeug.utils import secure_filename
import openai
from flask_sqlalchemy import SQLAlchemy

# --- Configuration ---
# It's recommended to use environment variables for sensitive data like API keys.
# You can create a .env file and use a library like python-dotenv to load them.
# Example: OPENAI_API_KEY="your_real_api_key"
openai.api_key = os.environ.get("OPENAI_API_KEY", "YOUR_OPENAI_API_KEY") 
UPLOAD_FOLDER = 'resumes_storage'
ALLOWED_EXTENSIONS = {'html'}

# --- App Initialization ---
app = Flask(__name__)
# Get the absolute path for the database file to avoid ambiguity.
basedir = os.path.abspath(os.path.dirname(__file__))
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///' + os.path.join(basedir, 'resumes.db')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER

# Initialize extensions
db = SQLAlchemy(app)

# Create the upload folder if it doesn't exist
if not os.path.exists(UPLOAD_FOLDER):
    os.makedirs(UPLOAD_FOLDER)

# --- SQLAlchemy Models ---
class User(db.Model):
    """Represents a user in the database."""
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(120), unique=True, nullable=False)
    # Establishes a one-to-many relationship with resumes
    # cascade="all, delete-orphan" ensures resumes are deleted when a user is deleted
    resumes = db.relationship('Resume', backref='user', lazy=True, cascade="all, delete-orphan")

    def __repr__(self):
        return f'<User {self.email}>'

class Resume(db.Model):
    """Represents a resume file in the database."""
    # The resume ID is a string, which can be a UUID generated by the client or server.
    id = db.Column(db.String(36), primary_key=True)
    filename = db.Column(db.String(200), nullable=False)
    # Foreign key to link this resume to a user
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)

    def __repr__(self):
        return f'<Resume {self.id}>'

# Create database tables from models if they don't exist
# This is safe to run every time the app starts.
with app.app_context():
    db.create_all()

# --- Helper Functions ---
def allowed_file(filename):
    """Checks if the file has an allowed extension."""
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

# --- API Endpoints ---

@app.route('/', methods=['GET'])
def root():
    """Root endpoint that returns server status."""
    return jsonify({"message": "Server running"}), 200

@app.route('/api/user', methods=['POST'])
def add_user():
    """Adds a new user to the database."""
    data = request.get_json()
    if not data or 'email' not in data:
        return jsonify({"error": "Email is required"}), 400

    email = data['email']
    # Check if user already exists
    if User.query.filter_by(email=email).first():
        return jsonify({"error": "User with this email already exists"}), 409

    # Create new user and save to DB
    new_user = User(email=email)
    db.session.add(new_user)
    db.session.commit()
    
    return jsonify({"message": f"User {email} added successfully"}), 201

@app.route('/api/resumes', methods=['GET'])
def get_user_resumes():
    """Gets all resume IDs for a given user from the database."""
    email = request.args.get('email')
    if not email:
        return jsonify({"error": "Email query parameter is required"}), 400

    user = User.query.filter_by(email=email).first()
    if not user:
        return jsonify({"error": "User not found"}), 404

    resume_ids = [resume.id for resume in user.resumes]
    return jsonify({"resume_ids": resume_ids}), 200

@app.route('/api/resumes/<string:resume_id>', methods=['GET', 'PUT', 'DELETE'])
def manage_resume(resume_id):
    """Manages a specific resume: fetch, update/create, or delete."""
    email = request.args.get('email')
    if not email:
        return jsonify({"error": "Email query parameter is required"}), 400

    user = User.query.filter_by(email=email).first()
    if not user:
        return jsonify({"error": "User not found"}), 404

    # --- DELETE Method ---
    if request.method == 'DELETE':
        resume = Resume.query.filter_by(id=resume_id, user_id=user.id).first()
        if not resume:
            return jsonify({"error": "Resume not found or access denied"}), 404
        
        filepath = os.path.join(app.config['UPLOAD_FOLDER'], resume.filename)
        if os.path.exists(filepath):
            os.remove(filepath)
            
        db.session.delete(resume)
        db.session.commit()
        return jsonify({"message": f"Resume {resume_id} deleted successfully"}), 200

    # --- GET Method ---
    if request.method == 'GET':
        resume = Resume.query.filter_by(id=resume_id, user_id=user.id).first()
        if not resume:
            return jsonify({"error": "Resume not found or access denied"}), 404
        
        return send_from_directory(app.config['UPLOAD_FOLDER'], resume.filename)

    # --- PUT Method (Upload/Create) ---
    if request.method == 'PUT':
        if 'file' not in request.files:
            return jsonify({"error": "No file part in the request"}), 400
        
        file = request.files['file']
        if file.filename == '' or not allowed_file(file.filename):
            return jsonify({"error": "Invalid or no selected file"}), 400
            
        filename = f"{resume_id}_{secure_filename(file.filename)}"
        filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        
        resume = Resume.query.filter_by(id=resume_id).first()
        if resume and resume.user_id != user.id:
            return jsonify({"error": "Resume ID belongs to another user"}), 403

        if resume: # Update existing resume record
            old_filepath = os.path.join(app.config['UPLOAD_FOLDER'], resume.filename)
            if os.path.exists(old_filepath):
                os.remove(old_filepath)
            resume.filename = filename
        else: # Create a new resume record
            resume = Resume(id=resume_id, filename=filename, user_id=user.id)
            db.session.add(resume)
            
        file.save(filepath)
        db.session.commit()
        
        return jsonify({
            "message": "Resume uploaded successfully",
            "resume_id": resume_id,
            "filename": filename
        }), 201

@app.route('/api/ai/generate', methods=['POST'])
def ai_generate():
    """Interacts with a resume using AI, saving changes to the database."""
    data = request.get_json()
    if not data or 'email' not in data or 'prompt' not in data:
        return jsonify({"error": "Email and prompt are required"}), 400

    email = data['email']
    prompt = data['prompt']
    resume_id = data.get('resume_id')

    user = User.query.filter_by(email=email).first()
    if not user:
        return jsonify({"error": "User not found"}), 404

    resume_content = ""
    resume = None
    if resume_id:
        resume = Resume.query.filter_by(id=resume_id, user_id=user.id).first()
        if not resume:
            return jsonify({"error": "Resume not found or access denied"}), 404
        
        filepath = os.path.join(app.config['UPLOAD_FOLDER'], resume.filename)
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                resume_content = f.read()
        except FileNotFoundError:
            return jsonify({"error": "Resume file not found on server"}), 500

    try:
        messages = [
            {"role": "system", "content": "You are a helpful resume assistant. The user will provide their resume and ask for modifications. You should return ONLY the complete, updated HTML of the resume. Do not add any explanatory text or markdown formatting like ```html before or after the code."},
            {"role": "user", "content": f"Here is my current resume HTML:\n\n{resume_content}\n\nPlease apply the following change: {prompt}"}
        ]

        response = openai.chat.completions.create(model="gpt-4o", messages=messages)
        updated_html = response.choices[0].message.content.strip()
        
        # Clean the response just in case the model adds markdown
        if updated_html.startswith("```html"): updated_html = updated_html[7:]
        if updated_html.endswith("```"): updated_html = updated_html[:-3]
        updated_html = updated_html.strip()

        if resume: # Update existing resume
            filepath = os.path.join(app.config['UPLOAD_FOLDER'], resume.filename)
            with open(filepath, 'w', encoding='utf-8') as f: f.write(updated_html)
            return jsonify({"message": "Resume updated", "resume_id": resume.id, "updated_content": updated_html})
        else: # Create a new resume
            new_resume_id = str(uuid.uuid4())
            new_filename = f"{new_resume_id}_ai_generated.html"
            new_filepath = os.path.join(app.config['UPLOAD_FOLDER'], new_filename)
            
            with open(new_filepath, 'w', encoding='utf-8') as f: f.write(updated_html)
            
            new_resume = Resume(id=new_resume_id, filename=new_filename, user_id=user.id)
            db.session.add(new_resume)
            db.session.commit()
            
            return jsonify({"message": "New resume generated", "resume_id": new_resume_id, "updated_content": updated_html}), 201

    except Exception as e:
        app.logger.error(f"AI generation failed: {e}")
        return jsonify({"error": f"An error occurred with the AI service: {str(e)}"}), 500

# --- Run the App ---
if __name__ == '__main__':
    # Use 0.0.0.0 to make the app accessible on your network
    app.run(host='0.0.0.0', port=5001, debug=True)
